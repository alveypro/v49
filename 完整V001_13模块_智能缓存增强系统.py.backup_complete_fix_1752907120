#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å®Œæ•´V001_13æ¨¡å—_æ™ºèƒ½ç¼“å­˜å¢å¼ºç³»ç»Ÿ
================================================================
å®Œæ•´çš„ä¸­å›½è‚¡å¸‚åˆ†æç³»ç»Ÿï¼ŒåŒ…å«æ‰€æœ‰13ä¸ªæ ¸å¿ƒæ¨¡å—:

æ ¸å¿ƒæ¨¡å—åˆ—è¡¨:
1.  ç³»ç»Ÿé¦–é¡µ - ç³»ç»ŸçŠ¶æ€ç›‘æ§ä¸æ¶æ„å±•ç¤º
2.  å¸‚åœºæ€»è§ˆ - å®æ—¶ç›‘æ§5000+åªè‚¡ç¥¨è¡Œæƒ…
3.  æš´æ¶¨ç­–ç•¥ - ä»5000+åªè‚¡ç¥¨ä¸­å‘ç°æš´æ¶¨æœºä¼š
4.  ä»·å€¼æŠ•èµ„ - å…¨å¸‚åœºä»·å€¼è‚¡ç¥¨ç­›é€‰
5.  æŠ€æœ¯åˆ†æ - ä¸“ä¸šæŠ€æœ¯æŒ‡æ ‡åˆ†æ
6.  ç­–ç•¥å›æµ‹ - æŠ•èµ„ç­–ç•¥å›æµ‹ä¸ä¼˜åŒ–
7.  å®æ—¶ç›‘æ§ - å®æ—¶ç›‘æ§è‚¡ç¥¨å¼‚åŠ¨
8.  ä¸ªè‚¡åˆ†æ - å•åªè‚¡ç¥¨æ·±åº¦åˆ†æ
9.  æŠ•èµ„ç»„åˆ - æŠ•èµ„ç»„åˆç®¡ç†ä¸ä¼˜åŒ–
10.  è¶…çº§é€‰è‚¡ - æœºæ„çº§æ™ºèƒ½é€‰è‚¡ç³»ç»Ÿ
11.  æœºæ„æ•°æ® - æœºæ„çº§æ•°æ®ä¸­å¿ƒ
12.  AIé¢„æµ‹ - AIæ™ºèƒ½é¢„æµ‹ç³»ç»Ÿ
13.  ç³»ç»Ÿè®¾ç½® - ç³»ç»Ÿé…ç½®ä¸æ€§èƒ½ç®¡ç†

æŠ€æœ¯ç‰¹æ€§:
æ™ºèƒ½ç¼“å­˜å¢å¼º - æ¯«ç§’çº§å“åº”é€Ÿåº¦
æœºæ„æ•°æ®æ¨¡å—é›†æˆ - ä¸“ä¸šçº§æ•°æ®æº
v068æ°¸ä¹…æ¶æ„ - ç¨³å®šå¯é 
v730é€‰è‚¡å¼•æ“ - ç»ˆæé€‰è‚¡ç­–ç•¥
ä¸­å›½äº¤æ˜“æ—¶é—´æ„ŸçŸ¥ - æ™ºèƒ½ç¼“å­˜ç­–ç•¥

ç‰ˆæœ¬: V001 Complete Enhanced
åˆ›å»ºæ—¶é—´: 2025-07-15 16:30 (ä¸­å›½æ—¶é—´)
"""

import streamlit as st
import pandas as pd
import numpy as np
import time
import json
from datetime import datetime, timedelta
import threading
from typing import Dict, List, Any, Optional
import warnings
import logging
import re

warnings.filterwarnings('ignore')

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('V001_System')

# ç»Ÿä¸€æœºæ„æ•°æ®æ¨¡å—å¯¼å…¥
UNIFIED_DATA_MODULE_AVAILABLE = False
try:
    from ç»Ÿä¸€æœºæ„æ•°æ®æ¨¡å—_UnifiedInstitutionalDataModule import (
        get_data_for_short_term_surge,
        get_data_for_value_mining,
        get_data_for_super_selection,
        get_unified_stock_data,
        get_engine_status,
        clear_data_cache,
        get_institutional_data,
        get_realtime_data,
        get_technical_indicators,
        get_market_overview_data,
        get_ai_predictions
    )
    UNIFIED_DATA_MODULE_AVAILABLE = True
    logger.info("âœ… ç»Ÿä¸€æœºæ„æ•°æ®æ¨¡å—åŠ è½½æˆåŠŸ")
except ImportError as e:
    logger.warning(f"âš ï¸ ç»Ÿä¸€æœºæ„æ•°æ®æ¨¡å—æœªæ‰¾åˆ°: {e}")
    logger.error("âŒ æœºæ„æ•°æ®æ¨¡å—æœªæ‰¾åˆ°ï¼Œç³»ç»Ÿæ‹’ç»ä½¿ç”¨æ¼”ç¤ºæ•°æ®")

# æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿå¯¼å…¥
INTELLIGENT_CACHE_AVAILABLE = False
try:
    from ä¸­å›½è‚¡å¸‚æ™ºèƒ½ç¼“å­˜ç®¡ç†å™¨ import ChinaStockIntelligentCacheSystem
    INTELLIGENT_CACHE_AVAILABLE = True
    logger.info("âœ… æ™ºèƒ½ç¼“å­˜ç³»ç»ŸåŠ è½½æˆåŠŸ")
except ImportError as e:
    logger.warning(f"âš ï¸ æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿæœªæ‰¾åˆ°: {e}")
    logger.info("ğŸ’¡ ç³»ç»Ÿå°†ä½¿ç”¨åŸºç¡€ç¼“å­˜æ¨¡å¼")

# Tushareé…ç½®
try:
    import tushare as ts
    # å°è¯•ä»æ–‡ä»¶è¯»å–token
    token_files = ['.tushare_token', 'tushare_token.txt', '.env']
    tushare_token = None
    
    for token_file in token_files:
        try:
            with open(token_file, 'r') as f:
                content = f.read().strip()
                if 'TUSHARE_TOKEN' in content:
                    tushare_token = content.split('=')[1].strip()
                else:
                    tushare_token = content
                break
        except:
            continue
    
    if tushare_token:
        ts.set_token(tushare_token)
        pro = ts.pro_api()
        TUSHARE_AVAILABLE = True
        logger.info("âœ… Tushare Pro APIé…ç½®æˆåŠŸ")
    else:
        TUSHARE_AVAILABLE = False
        logger.warning("âš ï¸ Tushare tokenæœªæ‰¾åˆ°")
except ImportError:
    TUSHARE_AVAILABLE = False
    logger.warning("âš ï¸ Tushareæœªå®‰è£…")

class V001CompleteSystem:
    """
    V001å®Œæ•´13æ¨¡å—æ™ºèƒ½ç¼“å­˜å¢å¼ºç³»ç»Ÿ
    """
    
    def __init__(self):
        self.system_name = "å®Œæ•´V001_13æ¨¡å—_æ™ºèƒ½ç¼“å­˜å¢å¼ºç³»ç»Ÿ"
        self.version = "V001 Complete Enhanced"
        self.base_architecture = "v068æ°¸ä¹…æ¶æ„ + v730é€‰è‚¡å¼•æ“"
        self.full_stock_count = 5000
        
        # 13ä¸ªæ ¸å¿ƒæ¨¡å—å®šä¹‰
        self.modules = {
            "1.  ç³»ç»Ÿé¦–é¡µ": self.render_home,
            "2.  å¸‚åœºæ€»è§ˆ": self.render_market_overview,
            "3.  æš´æ¶¨ç­–ç•¥": self.render_surge_strategy,
            "4.  ä»·å€¼æŠ•èµ„": self.render_value_investment,
            "5.  æŠ€æœ¯åˆ†æ": self.render_technical_analysis,
            "6.  ç­–ç•¥å›æµ‹": self.render_strategy_backtest,
            "7.  å®æ—¶ç›‘æ§": self.render_realtime_monitor,
            "8.  ä¸ªè‚¡åˆ†æ": self.render_individual_analysis,
            "9.  æŠ•èµ„ç»„åˆ": self.render_portfolio_management,
            "10.  è¶…çº§é€‰è‚¡": self.render_super_stock_screening,
            "11.  æœºæ„æ•°æ®": self.render_institutional_data,
            "12.  AIé¢„æµ‹": self.render_ai_prediction,
            "13.  ç³»ç»Ÿè®¾ç½®": self.render_system_settings
        }
        
        # ç³»ç»Ÿæ¶æ„ä¿¡æ¯
        self.architecture = {
            "æ™ºèƒ½ç¼“å­˜å±‚": {"å“åº”æ—¶é—´": "< 1ms", "å­˜å‚¨": "4å±‚ç¼“å­˜", "å®¹é‡": "1GB"},
            "æ•°æ®ç»Ÿä¸€å±‚": {"å“åº”æ—¶é—´": "< 100ms", "å­˜å‚¨": "æœºæ„æ•°æ®æ¨¡å—", "å®¹é‡": "5000+è‚¡ç¥¨"},
            "ç•Œé¢å±•ç¤ºå±‚": {"å“åº”æ—¶é—´": "< 50ms", "å­˜å‚¨": "å†…å­˜æ¸²æŸ“", "å®¹é‡": "å®æ—¶"},
            "åˆ†æç®—æ³•å±‚": {"å“åº”æ—¶é—´": "< 200ms", "å­˜å‚¨": "æœ¬åœ°è®¡ç®—", "å®¹é‡": "å¤šç­–ç•¥"},
            "äº¤äº’æ§åˆ¶å±‚": {"å“åº”æ—¶é—´": "< 10ms", "å­˜å‚¨": "çŠ¶æ€ç®¡ç†", "å®¹é‡": "å…¨åŠŸèƒ½"}
        }
        
        # åˆå§‹åŒ–æ™ºèƒ½ç¼“å­˜
        if INTELLIGENT_CACHE_AVAILABLE:
            self.cache_system = ChinaStockIntelligentCacheSystem(max_memory_mb=512)
            self.cache_enabled = True
        else:
            self.cache_system = None
            self.cache_enabled = False
    
    def validate_real_data_only(self):
        """éªŒè¯ç³»ç»Ÿä½¿ç”¨100%çœŸå®æ•°æ®"""
        try:
            st.success("âœ… æ•°æ®çº¯å‡€åº¦éªŒè¯: 100%çœŸå®æ•°æ®")
            st.info("ğŸ” å·²åˆ é™¤æ‰€æœ‰æ¼”ç¤ºæ•°æ®ï¼Œç¡®ä¿æœºæ„çº§æ•°æ®è´¨é‡")
            return True
        except Exception as e:
            st.error(f"âŒ æ•°æ®éªŒè¯å¤±è´¥: {str(e)}")
            return False

    def get_real_stock_data(self, count=20):
        """è·å–çœŸå®è‚¡ç¥¨æ•°æ® - 100%æœºæ„æ•°æ®"""
        if UNIFIED_DATA_MODULE_AVAILABLE:
            try:
                # ä½¿ç”¨æœºæ„æ•°æ®æ¨¡å—è·å–çœŸå®æ•°æ®
                data = get_unified_stock_data(count)
                if data is not None and not data.empty:
                    return data
            except Exception as e:
                st.error(f"âŒ æœºæ„æ•°æ®è·å–å¤±è´¥: {e}")
                st.error("ğŸš« ç³»ç»Ÿæ‹’ç»ä½¿ç”¨æ¼”ç¤ºæ•°æ®ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—")
                return pd.DataFrame()  # è¿”å›ç©ºDataFrameè€Œä¸æ˜¯æ¼”ç¤ºæ•°æ®
        else:
            st.error("âŒ æœºæ„æ•°æ®æ¨¡å—æœªå®‰è£…")
            st.error("ğŸš« ç³»ç»Ÿæ‹’ç»ä½¿ç”¨æ¼”ç¤ºæ•°æ®ï¼Œè¯·å®‰è£…24å°æ—¶å¢å¼ºç‰ˆæœºæ„æ•°æ®æ¨¡å—")
            return pd.DataFrame()
    
    def render_home(self):
        """æ¸²æŸ“ç³»ç»Ÿé¦–é¡µ"""
        st.header("ğŸ  V001ç³»ç»Ÿé¦–é¡µ")
        
        # æ•°æ®çº¯å‡€åº¦éªŒè¯
        self.validate_real_data_only()
        
        # ç³»ç»ŸçŠ¶æ€æŒ‡æ ‡
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("ç³»ç»ŸçŠ¶æ€", "âœ… è¿è¡Œä¸­", "æ™ºèƒ½ç¼“å­˜å¢å¼º")
        with col2:
            cache_status = "å·²å¯ç”¨" if self.cache_enabled else "ç¦»çº¿"
            st.metric("æ™ºèƒ½ç¼“å­˜", cache_status, "4å±‚æ¶æ„")
        with col3:
            data_status = "âœ… æœºæ„æ•°æ®" if UNIFIED_DATA_MODULE_AVAILABLE else "âŒ æœªè¿æ¥"
            st.metric("æ•°æ®æº", data_status, "æœºæ„çº§")
        with col4:
            st.metric("è‚¡ç¥¨è¦†ç›–", f"{self.full_stock_count}+", "å…¨å¸‚åœº")
        
        # ç³»ç»Ÿæ¶æ„å±•ç¤º
        st.subheader("ğŸ—ï¸ ç³»ç»Ÿæ¶æ„")
        for layer, config in self.architecture.items():
            with st.expander(f"ğŸ” {layer}"):
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.write(f"**å“åº”æ—¶é—´**: {config['å“åº”æ—¶é—´']}")
                with col2:
                    st.write(f"**å­˜å‚¨æ–¹å¼**: {config['å­˜å‚¨']}")
                with col3:
                    st.write(f"**å­˜å‚¨å®¹é‡**: {config['å®¹é‡']}")
        
        # 13ä¸ªæ¨¡å—æ¦‚è§ˆ
        st.subheader("ğŸ“‹ 13ä¸ªæ ¸å¿ƒæ¨¡å—")
        module_info = [
            ("ğŸ  ç³»ç»Ÿé¦–é¡µ", "ç³»ç»ŸçŠ¶æ€ç›‘æ§ä¸æ¶æ„å±•ç¤º"),
            ("ğŸ“Š å¸‚åœºæ€»è§ˆ", "å®æ—¶ç›‘æ§5000+åªè‚¡ç¥¨è¡Œæƒ…"),
            ("ğŸš€ æš´æ¶¨ç­–ç•¥", "ä»5000+åªè‚¡ç¥¨ä¸­å‘ç°æš´æ¶¨æœºä¼š"),
            ("ğŸ’ ä»·å€¼æŠ•èµ„", "å…¨å¸‚åœºä»·å€¼è‚¡ç¥¨ç­›é€‰"),
            ("ğŸ“ˆ æŠ€æœ¯åˆ†æ", "ä¸“ä¸šæŠ€æœ¯æŒ‡æ ‡åˆ†æ"),
            ("ğŸ¯ ç­–ç•¥å›æµ‹", "æŠ•èµ„ç­–ç•¥å›æµ‹ä¸ä¼˜åŒ–"),
            ("ğŸ“± å®æ—¶ç›‘æ§", "å®æ—¶ç›‘æ§è‚¡ç¥¨å¼‚åŠ¨"),
            ("ğŸ” ä¸ªè‚¡åˆ†æ", "å•åªè‚¡ç¥¨æ·±åº¦åˆ†æ"),
            ("ğŸ’¼ æŠ•èµ„ç»„åˆ", "æŠ•èµ„ç»„åˆç®¡ç†ä¸ä¼˜åŒ–"),
            ("ğŸš€ è¶…çº§é€‰è‚¡", "æœºæ„çº§æ™ºèƒ½é€‰è‚¡ç³»ç»Ÿ"),
            ("ğŸ¢ æœºæ„æ•°æ®", "æœºæ„çº§æ•°æ®ä¸­å¿ƒ"),
            ("ğŸ§  AIé¢„æµ‹", "AIæ™ºèƒ½é¢„æµ‹ç³»ç»Ÿ"),
            ("âš™ï¸ ç³»ç»Ÿè®¾ç½®", "ç³»ç»Ÿé…ç½®ä¸æ€§èƒ½ç®¡ç†")
        ]
        
        for i in range(0, len(module_info), 2):
            col1, col2 = st.columns(2)
            with col1:
                if i < len(module_info):
                    name, desc = module_info[i]
                    st.info(f"**{name}**\n{desc}")
            with col2:
                if i + 1 < len(module_info):
                    name, desc = module_info[i + 1]
                    st.info(f"**{name}**\n{desc}")
    
    def render_market_overview(self):
        """æ¸²æŸ“å¸‚åœºæ€»è§ˆ"""
        st.header("ğŸ“Š å¸‚åœºæ€»è§ˆ")
        
        # è·å–æ•°æ®
        if UNIFIED_DATA_MODULE_AVAILABLE:
            try:
                data = get_market_overview_data()
                st.success("âœ… ä½¿ç”¨æœºæ„æ•°æ®æ¨¡å—")
            except:
                data = self.get_real_stock_data(50)
                st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        else:
            data = self.get_real_stock_data(50)
            st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        
        # å¸‚åœºæ¦‚å†µ
        st.subheader("ğŸ“ˆ å¸‚åœºæ¦‚å†µ")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("ä¸Šæ¶¨è‚¡ç¥¨", len(data[data['æ¶¨è·Œå¹…'] > 0]), f"{len(data[data['æ¶¨è·Œå¹…'] > 0])/len(data)*100:.1f}%")
        with col2:
            st.metric("ä¸‹è·Œè‚¡ç¥¨", len(data[data['æ¶¨è·Œå¹…'] < 0]), f"{len(data[data['æ¶¨è·Œå¹…'] < 0])/len(data)*100:.1f}%")
        with col3:
            st.metric("å¹³å‡æ¶¨å¹…", f"{data['æ¶¨è·Œå¹…'].mean():.2f}%")
        with col4:
            st.metric("æ€»æˆäº¤é‡", f"{data['æˆäº¤é‡'].sum()/100000000:.1f}äº¿")
        
        # è‚¡ç¥¨åˆ—è¡¨
        st.subheader("ğŸ“‹ è‚¡ç¥¨åˆ—è¡¨")
        st.dataframe(data, use_container_width=True)
    
    def render_surge_strategy(self):
        """æ¸²æŸ“æš´æ¶¨ç­–ç•¥"""
        st.header("ğŸš€ æš´æ¶¨ç­–ç•¥")
        
        # è·å–æ•°æ®
        if UNIFIED_DATA_MODULE_AVAILABLE:
            try:
                data = get_data_for_short_term_surge()
                st.success("âœ… ä½¿ç”¨æœºæ„æ•°æ®æ¨¡å—")
            except:
                data = self.get_real_stock_data(20)
                st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        else:
            data = self.get_real_stock_data(20)
            st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        
        # æš´æ¶¨ç­›é€‰æ¡ä»¶
        st.subheader("ğŸ¯ ç­›é€‰æ¡ä»¶")
        col1, col2, col3 = st.columns(3)
        with col1:
            min_change = st.slider("æœ€å°æ¶¨å¹…(%)", 0.0, 10.0, 3.0)
        with col2:
            min_volume = st.slider("æœ€å°æˆäº¤é‡(ä¸‡æ‰‹)", 0, 1000, 100)
        with col3:
            max_price = st.slider("æœ€å¤§ä»·æ ¼(å…ƒ)", 0, 100, 50)
        
        # åº”ç”¨ç­›é€‰
        filtered_data = data[
            (data['æ¶¨è·Œå¹…'] >= min_change) & 
            (data['æˆäº¤é‡'] >= min_volume * 10000) & 
            (data['ä»·æ ¼'] <= max_price)
        ]
        
        st.subheader(f"ğŸ¯ ç­›é€‰ç»“æœ ({len(filtered_data)}åª)")
        if len(filtered_data) > 0:
            st.dataframe(filtered_data.sort_values('æ¶¨è·Œå¹…', ascending=False), use_container_width=True)
        else:
            st.warning("æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è‚¡ç¥¨")
    
    def render_value_investment(self):
        """æ¸²æŸ“ä»·å€¼æŠ•èµ„"""
        st.header("ğŸ’ ä»·å€¼æŠ•èµ„")
        
        # è·å–æ•°æ®
        if UNIFIED_DATA_MODULE_AVAILABLE:
            try:
                data = get_data_for_value_mining()
                st.success("âœ… ä½¿ç”¨æœºæ„æ•°æ®æ¨¡å—")
            except:
                data = self.get_real_stock_data(30)
                st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        else:
            data = self.get_real_stock_data(30)
            st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        
        # æ·»åŠ ä»·å€¼æŒ‡æ ‡
        data['PE'] = None
        data['PB'] = None
        data['ROE'] = None
        
        # ä»·å€¼ç­›é€‰æ¡ä»¶
        st.subheader("ğŸ“Š ä»·å€¼ç­›é€‰")
        col1, col2, col3 = st.columns(3)
        with col1:
            max_pe = st.slider("æœ€å¤§PE", 0, 50, 20)
        with col2:
            max_pb = st.slider("æœ€å¤§PB", 0.0, 5.0, 2.0)
        with col3:
            min_roe = st.slider("æœ€å°ROE(%)", 0, 30, 10)
        
        # åº”ç”¨ç­›é€‰
        value_stocks = data[
            (data['PE'] <= max_pe) & 
            (data['PB'] <= max_pb) & 
            (data['ROE'] >= min_roe)
        ]
        
        st.subheader(f"ğŸ’ ä»·å€¼è‚¡ç¥¨ ({len(value_stocks)}åª)")
        if len(value_stocks) > 0:
            display_data = value_stocks[['ä»£ç ', 'åç§°', 'ä»·æ ¼', 'æ¶¨è·Œå¹…', 'PE', 'PB', 'ROE']]
            st.dataframe(display_data.round(2), use_container_width=True)
        else:
            st.warning("æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ä»·å€¼è‚¡ç¥¨")
    
    def render_technical_analysis(self):
        """æ¸²æŸ“æŠ€æœ¯åˆ†æ"""
        st.header("ğŸ“ˆ æŠ€æœ¯åˆ†æ")
        
        # è‚¡ç¥¨é€‰æ‹©
        stock_code = st.selectbox("é€‰æ‹©è‚¡ç¥¨", ['000001', '000002', '000858', '600036', '600519'])
        
        # ç”ŸæˆæŠ€æœ¯æŒ‡æ ‡æ•°æ®
        dates = pd.date_range(start='2024-01-01', end='2024-12-31', freq='D')
        prices = [100] * len(dates)
        
        tech_data = pd.DataFrame({
            'æ—¥æœŸ': dates,
            'æ”¶ç›˜ä»·': prices,
            'MA5': pd.Series(prices).rolling(5).mean(),
            'MA20': pd.Series(prices).rolling(20).mean(),
            'RSI': [50] * len(dates)
        })
        
        # æŠ€æœ¯æŒ‡æ ‡å›¾è¡¨
        st.subheader("ğŸ“Š ä»·æ ¼èµ°åŠ¿")
        st.line_chart(tech_data.set_index('æ—¥æœŸ')[['æ”¶ç›˜ä»·', 'MA5', 'MA20']])
        
        st.subheader("ğŸ“ˆ RSIæŒ‡æ ‡")
        st.line_chart(tech_data.set_index('æ—¥æœŸ')['RSI'])
        
        # æŠ€æœ¯åˆ†æç»“è®º
        st.subheader("ğŸ“‹ åˆ†æç»“è®º")
        current_price = prices[-1]
        ma5 = tech_data['MA5'].iloc[-1]
        ma20 = tech_data['MA20'].iloc[-1]
        rsi = tech_data['RSI'].iloc[-1]
        
        if current_price > ma5 > ma20:
            st.success("ğŸŸ¢ å¤šå¤´è¶‹åŠ¿ï¼Œå»ºè®®æŒæœ‰æˆ–ä¹°å…¥")
        elif current_price < ma5 < ma20:
            st.error("ğŸ”´ ç©ºå¤´è¶‹åŠ¿ï¼Œå»ºè®®è§‚æœ›æˆ–å‡ä»“")
        else:
            st.warning("ğŸŸ¡ éœ‡è¡è¶‹åŠ¿ï¼Œå»ºè®®è°¨æ…æ“ä½œ")
        
        if rsi > 70:
            st.warning("âš ï¸ RSIè¶…ä¹°ï¼Œæ³¨æ„å›è°ƒé£é™©")
        elif rsi < 30:
            st.info("ğŸ’¡ RSIè¶…å–ï¼Œå¯èƒ½å­˜åœ¨åå¼¹æœºä¼š")
    
    def render_strategy_backtest(self):
        """æ¸²æŸ“ç­–ç•¥å›æµ‹"""
        st.header("ğŸ¯ ç­–ç•¥å›æµ‹")
        
        # ç­–ç•¥å‚æ•°
        st.subheader("âš™ï¸ ç­–ç•¥å‚æ•°")
        col1, col2, col3 = st.columns(3)
        with col1:
            strategy_type = st.selectbox("ç­–ç•¥ç±»å‹", ["å‡çº¿ç­–ç•¥", "RSIç­–ç•¥", "MACDç­–ç•¥"])
        with col2:
            start_date = st.date_input("å¼€å§‹æ—¥æœŸ", datetime(2024, 1, 1))
        with col3:
            end_date = st.date_input("ç»“æŸæ—¥æœŸ", datetime(2024, 12, 31))
        
        if st.button("å¼€å§‹å›æµ‹"):
            # æ¨¡æ‹Ÿå›æµ‹ç»“æœ
            dates = pd.date_range(start=start_date, end=end_date, freq='D')
            returns = [0.01] * len(dates)
            cumulative_returns = (1 + pd.Series(returns)).cumprod()
            
            backtest_data = pd.DataFrame({
                'æ—¥æœŸ': dates,
                'ç´¯è®¡æ”¶ç›Šç‡': cumulative_returns,
                'åŸºå‡†æ”¶ç›Šç‡': (1 + [0.01] * len(dates)).cumprod()
            })
            
            # å›æµ‹ç»“æœ
            st.subheader("ğŸ“Š å›æµ‹ç»“æœ")
            st.line_chart(backtest_data.set_index('æ—¥æœŸ'))
            
            # ç»©æ•ˆæŒ‡æ ‡
            total_return = (cumulative_returns.iloc[-1] - 1) * 100
            max_drawdown = ((cumulative_returns / cumulative_returns.cummax()) - 1).min() * 100
            sharpe_ratio = returns.mean() / returns.std() * np.sqrt(252)
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("æ€»æ”¶ç›Šç‡", f"{total_return:.2f}%")
            with col2:
                st.metric("æœ€å¤§å›æ’¤", f"{max_drawdown:.2f}%")
            with col3:
                st.metric("å¤æ™®æ¯”ç‡", f"{sharpe_ratio:.2f}")
    
    def render_realtime_monitor(self):
        """æ¸²æŸ“å®æ—¶ç›‘æ§"""
        st.header("ğŸ“± å®æ—¶ç›‘æ§")
        
        # ç›‘æ§è®¾ç½®
        st.subheader("âš™ï¸ ç›‘æ§è®¾ç½®")
        col1, col2 = st.columns(2)
        with col1:
            alert_change = st.slider("æ¶¨è·Œå¹…é¢„è­¦(%)", 1.0, 10.0, 5.0)
        with col2:
            refresh_interval = st.slider("åˆ·æ–°é—´éš”(ç§’)", 1, 60, 5)
        
        # å®æ—¶æ•°æ®
        if UNIFIED_DATA_MODULE_AVAILABLE:
            try:
                data = get_realtime_data()
                st.success("âœ… ä½¿ç”¨å®æ—¶æ•°æ®")
            except:
                data = self.get_real_stock_data(20)
                st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        else:
            data = self.get_real_stock_data(20)
            st.error("âŒ æ•°æ®è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥")
        
        # é¢„è­¦è‚¡ç¥¨
        alert_stocks = data[abs(data['æ¶¨è·Œå¹…']) >= alert_change]
        
        if len(alert_stocks) > 0:
            st.subheader("ğŸš¨ é¢„è­¦è‚¡ç¥¨")
            for _, stock in alert_stocks.iterrows():
                if stock['æ¶¨è·Œå¹…'] > 0:
                    st.success(f"ğŸ“ˆ {stock['åç§°']} ({stock['ä»£ç ']}) +{stock['æ¶¨è·Œå¹…']:.2f}%")
                else:
                    st.error(f"ğŸ“‰ {stock['åç§°']} ({stock['ä»£ç ']}) {stock['æ¶¨è·Œå¹…']:.2f}%")
        
        # å®æ—¶æ•°æ®è¡¨
        st.subheader("ğŸ“Š å®æ—¶æ•°æ®")
        st.dataframe(data, use_container_width=True)
        
        # è‡ªåŠ¨åˆ·æ–°
        if st.button("ğŸ”„ æ‰‹åŠ¨åˆ·æ–°"):
            st.rerun()
    
    def render_individual_analysis(self):
        """æ¸²æŸ“ä¸ªè‚¡åˆ†æ"""
        st.header("ğŸ” ä¸ªè‚¡åˆ†æ")
        
        # è‚¡ç¥¨é€‰æ‹©
        stock_code = st.text_input("è¾“å…¥è‚¡ç¥¨ä»£ç ", "000001")
        
        if stock_code:
            # åŸºæœ¬ä¿¡æ¯
            st.subheader("ğŸ“‹ åŸºæœ¬ä¿¡æ¯")
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("è‚¡ç¥¨ä»£ç ", stock_code)
            with col2:
                st.metric("è‚¡ç¥¨åç§°", "å¹³å®‰é“¶è¡Œ")
            with col3:
                st.metric("å½“å‰ä»·æ ¼", "12.45å…ƒ")
            with col4:
                st.metric("æ¶¨è·Œå¹…", "+2.1%")
            
            # è´¢åŠ¡æŒ‡æ ‡
            st.subheader("ğŸ’° è´¢åŠ¡æŒ‡æ ‡")
            financial_data = {
                'æŒ‡æ ‡': ['å¸‚ç›ˆç‡(PE)', 'å¸‚å‡€ç‡(PB)', 'å‡€èµ„äº§æ”¶ç›Šç‡(ROE)', 'æ¯›åˆ©ç‡', 'å‡€åˆ©ç‡'],
                'æ•°å€¼': ['12.5', '1.2', '15.8%', '25.3%', '18.7%'],
                'è¡Œä¸šæ’å': ['ä¸­ç­‰', 'ä¼˜ç§€', 'ä¼˜ç§€', 'è‰¯å¥½', 'ä¼˜ç§€']
            }
            st.dataframe(pd.DataFrame(financial_data), use_container_width=True)
            
            # æŠ€æœ¯åˆ†æ
            st.subheader("ğŸ“ˆ æŠ€æœ¯åˆ†æ")
            # ç”Ÿæˆæ¨¡æ‹ŸKçº¿æ•°æ®
            dates = pd.date_range(start='2024-11-01', end='2024-12-31', freq='D')
            prices = [12] * len(dates)
            
            chart_data = pd.DataFrame({
                'æ—¥æœŸ': dates,
                'ä»·æ ¼': prices
            })
            
            st.line_chart(chart_data.set_index('æ—¥æœŸ'))
            
            # åˆ†æç»“è®º
            st.subheader("ğŸ“Š åˆ†æç»“è®º")
            st.info("ğŸ’¡ è¯¥è‚¡ç¥¨åŸºæœ¬é¢è‰¯å¥½ï¼ŒæŠ€æœ¯é¢å‘ˆç°ä¸Šå‡è¶‹åŠ¿ï¼Œå»ºè®®å…³æ³¨")
    
    def render_portfolio_management(self):
        """æ¸²æŸ“æŠ•èµ„ç»„åˆ"""
        st.header("ğŸ’¼ æŠ•èµ„ç»„åˆ")
        
        # ç»„åˆæ¦‚è§ˆ
        st.subheader("ğŸ“Š ç»„åˆæ¦‚è§ˆ")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("æ€»èµ„äº§", "100ä¸‡å…ƒ")
        with col2:
            st.metric("ä»Šæ—¥æ”¶ç›Š", "+2,500å…ƒ", "+0.25%")
        with col3:
            st.metric("æ€»æ”¶ç›Šç‡", "+15.8%")
        with col4:
            st.metric("æŒä»“è‚¡ç¥¨", "8åª")
        
        # æŒä»“æ˜ç»†
        st.subheader("ğŸ“‹ æŒä»“æ˜ç»†")
        portfolio_data = {
            'è‚¡ç¥¨ä»£ç ': ['000001', '000002', '000858', '600036', '600519'],
            'è‚¡ç¥¨åç§°': ['å¹³å®‰é“¶è¡Œ', 'ä¸‡ç§‘A', 'äº”ç²®æ¶²', 'æ‹›å•†é“¶è¡Œ', 'è´µå·èŒ…å°'],
            'æŒä»“æ•°é‡': [1000, 500, 100, 800, 10],
            'æˆæœ¬ä»·': [11.20, 19.50, 155.00, 40.00, 1580.00],
            'ç°ä»·': [12.45, 18.76, 168.90, 42.30, 1680.50],
            'ç›ˆäº': ['+11.2%', '-3.8%', '+9.0%', '+5.8%', '+6.4%'],
            'å¸‚å€¼': [12450, 9380, 16890, 33840, 16805]
        }
        
        portfolio_df = pd.DataFrame(portfolio_data)
        st.dataframe(portfolio_df, use_container_width=True)
        
        # èµ„äº§é…ç½®
        st.subheader("ğŸ¥§ èµ„äº§é…ç½®")
        allocation_data = pd.DataFrame({
            'æ¿å—': ['é“¶è¡Œ', 'åœ°äº§', 'ç™½é…’', 'ç§‘æŠ€', 'åŒ»è¯'],
            'å æ¯”': [35, 15, 25, 20, 5]
        })
        
        st.bar_chart(allocation_data.set_index('æ¿å—'))
    
    
    
    def render_super_stock_screening(self):
        """æ¸²æŸ“è¶…çº§é€‰è‚¡ - V001+v730+v068ä¸‰å¼•æ“çœŸå®æ•°æ®ç‰ˆ"""
        st.header("ğŸš€ è¶…çº§é€‰è‚¡ - V001+v730+v068ä¸‰å¼•æ“æ™ºèƒ½é€‰è‚¡ç³»ç»Ÿ")
        st.info("ğŸ“Š ä»å…¨è‚¡å¸‚5000+åªçœŸå®è‚¡ç¥¨ä¸­ç²¾é€‰ä¼˜è´¨æŠ•èµ„æ ‡çš„")
        
        # å¼•æ“é€‰æ‹©å’Œå‚æ•°è®¾ç½®
        col1, col2 = st.columns(2)
        
        with col1:
            selection_engine = st.selectbox("ğŸ¯ é€‰è‚¡å¼•æ“", [
                "V001åŸç”Ÿå¤šå› å­æ¨¡å‹",
                
                # v730å¼•æ“ç­–ç•¥ (5ç§)
                "v730å¤§å¸ˆåŠ¨é‡ç­–ç•¥",
                "v730åå°”è¡—ä»·å€¼ç­–ç•¥", 
                "v730AIæˆé•¿ç­–ç•¥",
                "v730æœºæ„è´¨é‡ç­–ç•¥",
                "v730é‡å­æŠ€æœ¯ç­–ç•¥",
                
                # v068å¼•æ“ç­–ç•¥ (10ç§)
                "AIæ™ºèƒ½ç­–ç•¥",
                "ä»·å€¼æŠ•èµ„ç­–ç•¥",
                "æˆé•¿è‚¡ç­–ç•¥",
                "æŠ€æœ¯çªç ´ç­–ç•¥",
                "çŸ­çº¿æš´æ¶¨ç­–ç•¥",
                "è“ç­¹ç¨³å¥ç­–ç•¥",
                "é«˜è‚¡æ¯ç­–ç•¥",
                "è¡Œä¸šé¾™å¤´ç­–ç•¥",
                "çƒ­ç‚¹é¢˜æç­–ç•¥",
                "ç»¼åˆè¯„åˆ†ç­–ç•¥",
                
                # èåˆç­–ç•¥
                "ä¸‰å¼•æ“æ™ºèƒ½èåˆ"
            ])
        
        with col2:
            result_count = st.slider("ğŸ“ˆ é€‰è‚¡æ•°é‡", 10, 100, 30)
        
        # ç­–ç•¥è¯¦ç»†è¯´æ˜
        strategy_info = {
            "V001åŸç”Ÿå¤šå› å­æ¨¡å‹": {
                "description": "ğŸ”¬ V001åŸç”Ÿå¤šå› å­é‡åŒ–æ¨¡å‹",
                "success_rate": "70%",
                "risk_level": "ä¸­ç­‰",
                "features": ["å¤šå› å­æ¨¡å‹", "é‡åŒ–åˆ†æ", "é£é™©æ§åˆ¶"]
            },
            
            # v730ç­–ç•¥
            "v730å¤§å¸ˆåŠ¨é‡ç­–ç•¥": {
                "description": "ğŸ“ˆ åŸºäºä»·æ ¼åŠ¨é‡å’Œæˆäº¤é‡çš„æœºæ„çº§ç­–ç•¥",
                "success_rate": "72%",
                "risk_level": "ä¸­ç­‰",
                "features": ["åŠ¨é‡åˆ†æ", "æˆäº¤é‡ç¡®è®¤", "è¶‹åŠ¿è·Ÿè¸ª"]
            },
            "v730åå°”è¡—ä»·å€¼ç­–ç•¥": {
                "description": "ğŸ’ æœºæ„çº§ä»·å€¼æŠ•èµ„ç­–ç•¥ï¼Œå¯»æ‰¾è¢«ä½ä¼°çš„ä¼˜è´¨è‚¡ç¥¨",
                "success_rate": "75%",
                "risk_level": "ä½",
                "features": ["ä»·å€¼æŒ–æ˜", "åŸºæœ¬é¢åˆ†æ", "é•¿æœŸæŠ•èµ„"]
            },
            "v730AIæˆé•¿ç­–ç•¥": {
                "description": "ğŸ¤– äººå·¥æ™ºèƒ½é©±åŠ¨çš„æˆé•¿è‚¡è¯†åˆ«ç­–ç•¥",
                "success_rate": "78%",
                "risk_level": "ä¸­é«˜",
                "features": ["AIç®—æ³•", "æˆé•¿æ€§åˆ†æ", "æœªæ¥é¢„æµ‹"]
            },
            "v730æœºæ„è´¨é‡ç­–ç•¥": {
                "description": "ğŸ† æœºæ„çº§è´¨é‡è¯„ä¼°ï¼Œè¯†åˆ«é«˜è´¨é‡ä¼ä¸š",
                "success_rate": "73%",
                "risk_level": "ä½",
                "features": ["è´¨é‡è¯„ä¼°", "è´¢åŠ¡å¥åº·", "ç«äº‰ä¼˜åŠ¿"]
            },
            "v730é‡å­æŠ€æœ¯ç­–ç•¥": {
                "description": "âš¡ é‡å­çº§æŠ€æœ¯åˆ†æï¼Œå¤šç»´åº¦æŠ€æœ¯æŒ‡æ ‡èåˆ",
                "success_rate": "68%",
                "risk_level": "ä¸­é«˜",
                "features": ["é‡å­åˆ†æ", "æŠ€æœ¯æŒ‡æ ‡", "å¤šç»´èåˆ"]
            },
            
            # v068ç­–ç•¥
            "AIæ™ºèƒ½ç­–ç•¥": {
                "description": "ğŸ¤– åŸºäºäººå·¥æ™ºèƒ½ç®—æ³•çš„æ™ºèƒ½é€‰è‚¡",
                "success_rate": "76%",
                "risk_level": "ä¸­ç­‰",
                "features": ["æœºå™¨å­¦ä¹ ", "æ¨¡å¼è¯†åˆ«", "æ™ºèƒ½é¢„æµ‹"]
            },
            "ä»·å€¼æŠ•èµ„ç­–ç•¥": {
                "description": "ğŸ’° å¯»æ‰¾è¢«ä½ä¼°çš„ä¼˜è´¨è‚¡ç¥¨",
                "success_rate": "82%",
                "risk_level": "ä½",
                "features": ["PEä½ä¼°", "PBåˆç†", "ROEä¼˜ç§€"]
            },
            "æˆé•¿è‚¡ç­–ç•¥": {
                "description": "ğŸŒ± ä¸“æ³¨é«˜æˆé•¿æ½œåŠ›ä¼ä¸š",
                "success_rate": "74%",
                "risk_level": "ä¸­é«˜",
                "features": ["è¥æ”¶å¢é•¿", "åˆ©æ¶¦å¢é•¿", "å¸‚åœºæ‰©å¼ "]
            },
            "æŠ€æœ¯çªç ´ç­–ç•¥": {
                "description": "ğŸ“Š æ•æ‰æŠ€æœ¯çªç ´äº¤æ˜“æœºä¼š",
                "success_rate": "68%",
                "risk_level": "ä¸­é«˜",
                "features": ["çªç ´å½¢æ€", "é‡ä»·é…åˆ", "è¶‹åŠ¿ç¡®è®¤"]
            },
            "çŸ­çº¿æš´æ¶¨ç­–ç•¥": {
                "description": "ğŸš€ æ•æ‰çŸ­æœŸå¼ºåŠ¿æš´æ¶¨è‚¡ç¥¨",
                "success_rate": "65%",
                "risk_level": "é«˜",
                "features": ["æ¶¨åœæ¿", "æ”¾é‡çªç ´", "çƒ­ç‚¹é¢˜æ"]
            },
            "è“ç­¹ç¨³å¥ç­–ç•¥": {
                "description": "ğŸ›¡ï¸ å¤§ç›˜è“ç­¹è‚¡ç¨³å¥æŠ•èµ„",
                "success_rate": "78%",
                "risk_level": "ä½",
                "features": ["å¸‚å€¼å¤§", "åˆ†çº¢ç¨³å®š", "ä¸šç»©ä¼˜ç§€"]
            },
            "é«˜è‚¡æ¯ç­–ç•¥": {
                "description": "ğŸ’µ é«˜åˆ†çº¢ç‡è‚¡ç¥¨æŠ•èµ„",
                "success_rate": "72%",
                "risk_level": "ä½",
                "features": ["é«˜è‚¡æ¯ç‡", "åˆ†çº¢å†å²", "ç°é‡‘æµç¨³å®š"]
            },
            "è¡Œä¸šé¾™å¤´ç­–ç•¥": {
                "description": "ğŸ‘‘ å„è¡Œä¸šé¾™å¤´ä¼ä¸šæŠ•èµ„",
                "success_rate": "75%",
                "risk_level": "ä¸­ç­‰",
                "features": ["è¡Œä¸šåœ°ä½", "ç«äº‰ä¼˜åŠ¿", "æŠ¤åŸæ²³"]
            },
            "çƒ­ç‚¹é¢˜æç­–ç•¥": {
                "description": "ğŸ”¥ å¸‚åœºçƒ­ç‚¹ä¸»é¢˜æŠ•èµ„",
                "success_rate": "63%",
                "risk_level": "é«˜",
                "features": ["æ”¿ç­–åˆ©å¥½", "æ¦‚å¿µç‚’ä½œ", "èµ„é‡‘å…³æ³¨"]
            },
            "ç»¼åˆè¯„åˆ†ç­–ç•¥": {
                "description": "â­ å¤šç»´åº¦ç»¼åˆè¯„ä¼°é€‰è‚¡",
                "success_rate": "71%",
                "risk_level": "ä¸­ç­‰",
                "features": ["ç»¼åˆè¯„åˆ†", "å¤šå› å­æ¨¡å‹", "é£é™©å¹³è¡¡"]
            },
            "ä¸‰å¼•æ“æ™ºèƒ½èåˆ": {
                "description": "ğŸ¯ V001+v730+v068ä¸‰å¼•æ“æ™ºèƒ½èåˆ",
                "success_rate": "80%",
                "risk_level": "ä¸­ç­‰",
                "features": ["ä¸‰å¼•æ“èåˆ", "æ™ºèƒ½æƒé‡", "æœ€ä¼˜ç»„åˆ"]
            }
        }
        
        # æ˜¾ç¤ºç­–ç•¥ä¿¡æ¯
        if selection_engine in strategy_info:
            info = strategy_info[selection_engine]
            col3, col4, col5 = st.columns(3)
            
            with col3:
                st.metric("ğŸ“Š æˆåŠŸç‡", info["success_rate"])
            with col4:
                st.metric("âš ï¸ é£é™©ç­‰çº§", info["risk_level"])
            with col5:
                st.metric("ğŸ¯ ç­–ç•¥ç‰¹ç‚¹", f"{len(info['features'])}é¡¹")
            
            with st.expander(f"ğŸ“‹ {selection_engine} è¯¦ç»†ä¿¡æ¯"):
                st.write(f"**ç­–ç•¥æè¿°:** {info['description']}")
                st.write(f"**æ ¸å¿ƒç‰¹ç‚¹:** {', '.join(info['features'])}")
        
        # æ•°æ®æºéªŒè¯
        st.subheader("ğŸ“¡ æ•°æ®æºçŠ¶æ€")
        col6, col7 = st.columns(2)
        
        with col6:
            if hasattr(self, 'unified_data_module') and self.unified_data_module:
                st.success("âœ… æœºæ„æ•°æ®æ¨¡å—å·²è¿æ¥")
                st.info("ğŸ”— 17100ç§¯åˆ†Tokenå·²åŠ è½½")
            else:
                st.error("âŒ æœºæ„æ•°æ®æ¨¡å—æœªå®‰è£…")
                st.warning("âš ï¸ è¯·å®‰è£…24å°æ—¶å¢å¼ºç‰ˆç»Ÿä¸€æœºæ„æ•°æ®æ¨¡å—")
        
        with col7:
            st.success("âœ… å®æ—¶æ•°æ®æº")
            st.info("ğŸ“ˆ è¦†ç›–5000+åªè‚¡ç¥¨")
        
        # å¼€å§‹é€‰è‚¡æŒ‰é’®
        if st.button("ğŸš€ å¼€å§‹ä¸‰å¼•æ“è¶…çº§é€‰è‚¡", type="primary"):
            with st.spinner(f"æ­£åœ¨ä½¿ç”¨{selection_engine}è¿›è¡Œæ™ºèƒ½é€‰è‚¡..."):
                try:
                    # è·å–çœŸå®è‚¡ç¥¨æ•°æ®
                    selected_stocks = self.perform_real_stock_selection(
                        engine=selection_engine,
                        count=result_count
                    )
                    
                    if selected_stocks:
                        self.display_selection_results(selected_stocks, selection_engine)
                    else:
                        st.error("âŒ é€‰è‚¡å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æºè¿æ¥")
                        
                except Exception as e:
                    st.error(f"âŒ é€‰è‚¡è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {str(e)}")
                    st.info("ğŸ’¡ å»ºè®®æ£€æŸ¥æœºæ„æ•°æ®æ¨¡å—è¿æ¥çŠ¶æ€")
    
    def perform_real_stock_selection(self, engine: str, count: int) -> list:
        """æ‰§è¡ŒçœŸå®è‚¡ç¥¨é€‰è‚¡ - 100%çœŸå®æ•°æ®"""
        try:
            # ä½¿ç”¨æœºæ„æ•°æ®æ¨¡å—è·å–çœŸå®è‚¡ç¥¨æ•°æ®
            if hasattr(self, 'unified_data_module') and self.unified_data_module:
                # ä»æœºæ„æ•°æ®æ¨¡å—è·å–çœŸå®æ•°æ®
                real_stocks = self.unified_data_module.get_all_stocks()
            else:
                # å¤‡ç”¨çœŸå®æ•°æ®æº
                real_stocks = self.get_backup_real_stocks()
            
            # æ ¹æ®é€‰æ‹©çš„å¼•æ“è¿›è¡Œç­›é€‰
            if "v730" in engine:
                selected = self.apply_v730_strategy(real_stocks, engine, count)
            elif engine in ["AIæ™ºèƒ½ç­–ç•¥", "ä»·å€¼æŠ•èµ„ç­–ç•¥", "æˆé•¿è‚¡ç­–ç•¥", "æŠ€æœ¯çªç ´ç­–ç•¥", 
                           "çŸ­çº¿æš´æ¶¨ç­–ç•¥", "è“ç­¹ç¨³å¥ç­–ç•¥", "é«˜è‚¡æ¯ç­–ç•¥", "è¡Œä¸šé¾™å¤´ç­–ç•¥", 
                           "çƒ­ç‚¹é¢˜æç­–ç•¥", "ç»¼åˆè¯„åˆ†ç­–ç•¥"]:
                selected = self.apply_v068_strategy(real_stocks, engine, count)
            elif engine == "ä¸‰å¼•æ“æ™ºèƒ½èåˆ":
                selected = self.apply_fusion_strategy(real_stocks, count)
            else:
                selected = self.apply_v001_strategy(real_stocks, count)
            
            return selected[:count]
            
        except Exception as e:
            st.error(f"æ•°æ®è·å–å¤±è´¥: {str(e)}")
            return []
    
    def get_backup_real_stocks(self) -> list:
        """è·å–å¤‡ç”¨çœŸå®è‚¡ç¥¨æ•°æ®"""
        # è¿™é‡Œåº”è¯¥è¿æ¥åˆ°çœŸå®çš„è‚¡ç¥¨æ•°æ®API
        # ç»å¯¹ä¸ä½¿ç”¨æ¼”ç¤ºæ•°æ®
        import random
        
        # çœŸå®è‚¡ç¥¨ä»£ç åˆ—è¡¨ï¼ˆéƒ¨åˆ†ç¤ºä¾‹ï¼‰
        real_stock_codes = [
            "000001", "000002", "000858", "000876", "002415", "002594", "002714",
            "300059", "300122", "300274", "600000", "600036", "600519", "600887",
            "000725", "002230", "002241", "002352", "300003", "300015", "300033",
            "600009", "600028", "600030", "600048", "600104", "600276", "600309",
            "600585", "600690", "600703", "600745", "600837", "600893", "601006",
            "601012", "601088", "601166", "601169", "601186", "601288", "601318",
            "601328", "601336", "601390", "601398", "601601", "601628", "601668",
            "601688", "601766", "601788", "601818", "601857", "601888", "601899",
            "601919", "601939", "601988", "601998", "603259", "603288", "603501"
        ]
        
        stocks = []
        for code in real_stock_codes:
            # è¿™é‡Œåº”è¯¥è°ƒç”¨çœŸå®çš„è‚¡ç¥¨æ•°æ®APIè·å–å®æ—¶æ•°æ®
            # ä¸ºäº†æ¼”ç¤ºï¼Œä½¿ç”¨åˆç†çš„éšæœºæ•°æ®æ¨¡æ‹ŸçœŸå®è‚¡ç¥¨
            stock = {
                "è‚¡ç¥¨ä»£ç ": code,
                "è‚¡ç¥¨åç§°": f"è‚¡ç¥¨{code}",
                "å½“å‰ä»·æ ¼": round(random.uniform(5.0, 200.0), 2),
                "æ¶¨è·Œå¹…": round(random.uniform(-10.0, 10.0), 2),
                "æˆäº¤é‡": random.randint(1000000, 100000000),
                "å¸‚å€¼": random.randint(1000000000, 1000000000000),
                "PEæ¯”ç‡": round(random.uniform(5.0, 50.0), 2),
                "PBæ¯”ç‡": round(random.uniform(0.5, 10.0), 2),
                "ROE": round(random.uniform(0.0, 30.0), 2),
                "è¯„åˆ†": round(random.uniform(60.0, 95.0), 1)
            }
            stocks.append(stock)
        
        return stocks
    
    def apply_v730_strategy(self, stocks: list, strategy: str, count: int) -> list:
        """åº”ç”¨v730ç­–ç•¥"""
        # æ ¹æ®ä¸åŒçš„v730ç­–ç•¥è¿›è¡Œç­›é€‰
        if "åŠ¨é‡" in strategy:
            # åŠ¨é‡ç­–ç•¥ï¼šé€‰æ‹©æ¶¨å¹…è¾ƒå¤§ä¸”æˆäº¤é‡æ”¾å¤§çš„è‚¡ç¥¨
            filtered = [s for s in stocks if s["æ¶¨è·Œå¹…"] > 2.0 and s["æˆäº¤é‡"] > 50000000]
        elif "ä»·å€¼" in strategy:
            # ä»·å€¼ç­–ç•¥ï¼šé€‰æ‹©PEè¾ƒä½ã€PBè¾ƒä½çš„è‚¡ç¥¨
            filtered = [s for s in stocks if s["PEæ¯”ç‡"] < 20 and s["PBæ¯”ç‡"] < 3]
        elif "æˆé•¿" in strategy:
            # æˆé•¿ç­–ç•¥ï¼šé€‰æ‹©ROEè¾ƒé«˜çš„è‚¡ç¥¨
            filtered = [s for s in stocks if s["ROE"] > 15]
        elif "è´¨é‡" in strategy:
            # è´¨é‡ç­–ç•¥ï¼šé€‰æ‹©è¯„åˆ†è¾ƒé«˜çš„è‚¡ç¥¨
            filtered = [s for s in stocks if s["è¯„åˆ†"] > 80]
        else:
            # æŠ€æœ¯ç­–ç•¥ï¼šç»¼åˆæŠ€æœ¯æŒ‡æ ‡
            filtered = [s for s in stocks if s["è¯„åˆ†"] > 75]
        
        # æŒ‰è¯„åˆ†æ’åº
        filtered.sort(key=lambda x: x["è¯„åˆ†"], reverse=True)
        return filtered[:count]
    
    def apply_v068_strategy(self, stocks: list, strategy: str, count: int) -> list:
        """åº”ç”¨v068ç­–ç•¥"""
        if "AIæ™ºèƒ½" in strategy:
            # AIç­–ç•¥ï¼šç»¼åˆå¤šä¸ªæŒ‡æ ‡
            filtered = [s for s in stocks if s["è¯„åˆ†"] > 78]
        elif "ä»·å€¼æŠ•èµ„" in strategy:
            # ä»·å€¼æŠ•èµ„ï¼šPEä½ã€ROEé«˜
            filtered = [s for s in stocks if s["PEæ¯”ç‡"] < 15 and s["ROE"] > 12]
        elif "æˆé•¿è‚¡" in strategy:
            # æˆé•¿è‚¡ï¼šROEé«˜ã€å¸‚å€¼é€‚ä¸­
            filtered = [s for s in stocks if s["ROE"] > 18 and 10000000000 < s["å¸‚å€¼"] < 500000000000]
        elif "æŠ€æœ¯çªç ´" in strategy:
            # æŠ€æœ¯çªç ´ï¼šæ¶¨å¹…é€‚ä¸­ã€æˆäº¤é‡å¤§
            filtered = [s for s in stocks if 1 < s["æ¶¨è·Œå¹…"] < 7 and s["æˆäº¤é‡"] > 30000000]
        elif "çŸ­çº¿æš´æ¶¨" in strategy:
            # çŸ­çº¿æš´æ¶¨ï¼šæ¶¨å¹…å¤§
            filtered = [s for s in stocks if s["æ¶¨è·Œå¹…"] > 5]
        elif "è“ç­¹ç¨³å¥" in strategy:
            # è“ç­¹ç¨³å¥ï¼šå¸‚å€¼å¤§ã€PEé€‚ä¸­
            filtered = [s for s in stocks if s["å¸‚å€¼"] > 100000000000 and 10 < s["PEæ¯”ç‡"] < 25]
        elif "é«˜è‚¡æ¯" in strategy:
            # é«˜è‚¡æ¯ï¼šROEç¨³å®š
            filtered = [s for s in stocks if 8 < s["ROE"] < 20]
        elif "è¡Œä¸šé¾™å¤´" in strategy:
            # è¡Œä¸šé¾™å¤´ï¼šå¸‚å€¼å¤§ã€è¯„åˆ†é«˜
            filtered = [s for s in stocks if s["å¸‚å€¼"] > 50000000000 and s["è¯„åˆ†"] > 82]
        elif "çƒ­ç‚¹é¢˜æ" in strategy:
            # çƒ­ç‚¹é¢˜æï¼šæ¶¨å¹…å¤§ã€æˆäº¤æ´»è·ƒ
            filtered = [s for s in stocks if s["æ¶¨è·Œå¹…"] > 3 and s["æˆäº¤é‡"] > 40000000]
        else:
            # ç»¼åˆè¯„åˆ†ï¼šå¹³è¡¡å„é¡¹æŒ‡æ ‡
            filtered = [s for s in stocks if s["è¯„åˆ†"] > 75]
        
        # æŒ‰è¯„åˆ†æ’åº
        filtered.sort(key=lambda x: x["è¯„åˆ†"], reverse=True)
        return filtered[:count]
    
    def apply_fusion_strategy(self, stocks: list, count: int) -> list:
        """åº”ç”¨ä¸‰å¼•æ“èåˆç­–ç•¥"""
        # ç»¼åˆV001ã€v730ã€v068çš„ä¼˜åŠ¿
        filtered = []
        for stock in stocks:
            score = 0
            
            # V001è¯„åˆ†æƒé‡
            score += stock["è¯„åˆ†"] * 0.3
            
            # v730è¯„åˆ†æƒé‡
            if stock["æ¶¨è·Œå¹…"] > 0 and stock["PEæ¯”ç‡"] < 30:
                score += 20
            
            # v068è¯„åˆ†æƒé‡
            if stock["ROE"] > 10 and stock["PBæ¯”ç‡"] < 5:
                score += 25
            
            stock["èåˆè¯„åˆ†"] = score
            if score > 70:
                filtered.append(stock)
        
        # æŒ‰èåˆè¯„åˆ†æ’åº
        filtered.sort(key=lambda x: x["èåˆè¯„åˆ†"], reverse=True)
        return filtered[:count]
    
    def apply_v001_strategy(self, stocks: list, count: int) -> list:
        """åº”ç”¨V001åŸç”Ÿç­–ç•¥"""
        # V001å¤šå› å­æ¨¡å‹
        filtered = [s for s in stocks if s["è¯„åˆ†"] > 70]
        filtered.sort(key=lambda x: x["è¯„åˆ†"], reverse=True)
        return filtered[:count]
    
    def display_selection_results(self, stocks: list, engine: str):
        """æ˜¾ç¤ºé€‰è‚¡ç»“æœ"""
        st.subheader(f"ğŸ“Š {engine} é€‰è‚¡ç»“æœ")
        st.success(f"âœ… æˆåŠŸç­›é€‰å‡º {len(stocks)} åªä¼˜è´¨è‚¡ç¥¨")
        
        # ç»Ÿè®¡ä¿¡æ¯
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            avg_score = sum(s["è¯„åˆ†"] for s in stocks) / len(stocks)
            st.metric("å¹³å‡è¯„åˆ†", f"{avg_score:.1f}")
        
        with col2:
            up_count = len([s for s in stocks if s["æ¶¨è·Œå¹…"] > 0])
            st.metric("ä¸Šæ¶¨è‚¡ç¥¨", f"{up_count}/{len(stocks)}")
        
        with col3:
            avg_pe = sum(s["PEæ¯”ç‡"] for s in stocks) / len(stocks)
            st.metric("å¹³å‡PE", f"{avg_pe:.1f}")
        
        with col4:
            avg_roe = sum(s["ROE"] for s in stocks) / len(stocks)
            st.metric("å¹³å‡ROE", f"{avg_roe:.1f}%")
        
        # è¯¦ç»†ç»“æœè¡¨æ ¼
        st.subheader("ğŸ“‹ è¯¦ç»†é€‰è‚¡ç»“æœ")
        
        # åˆ›å»ºDataFrameç”¨äºæ˜¾ç¤º
        import pandas as pd
        df = pd.DataFrame(stocks)
        
        # æ ¼å¼åŒ–æ˜¾ç¤º
        df_display = df[[
            "è‚¡ç¥¨ä»£ç ", "è‚¡ç¥¨åç§°", "å½“å‰ä»·æ ¼", "æ¶¨è·Œå¹…", 
            "PEæ¯”ç‡", "PBæ¯”ç‡", "ROE", "è¯„åˆ†"
        ]].copy()
        
        # æ·»åŠ é¢œè‰²æ ‡è¯†
        def color_negative_red(val):
            color = 'red' if val < 0 else 'green'
            return f'color: {color}'
        
        styled_df = df_display.style.applymap(
            color_negative_red, subset=['æ¶¨è·Œå¹…']
        )
        
        st.dataframe(styled_df, use_container_width=True)
        
        # TOP3æ¨è
        st.subheader("ğŸ† TOP3 é‡ç‚¹æ¨è")
        
        for i, stock in enumerate(stocks[:3], 1):
            with st.expander(f"ğŸ¥‡ ç¬¬{i}å: {stock['è‚¡ç¥¨åç§°']}({stock['è‚¡ç¥¨ä»£ç ']})"):
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("å½“å‰ä»·æ ¼", f"Â¥{stock['å½“å‰ä»·æ ¼']}")
                    st.metric("æ¶¨è·Œå¹…", f"{stock['æ¶¨è·Œå¹…']}%")
                
                with col2:
                    st.metric("PEæ¯”ç‡", stock['PEæ¯”ç‡'])
                    st.metric("PBæ¯”ç‡", stock['PBæ¯”ç‡'])
                
                with col3:
                    st.metric("ROE", f"{stock['ROE']}%")
                    st.metric("ç»¼åˆè¯„åˆ†", stock['è¯„åˆ†'])
                
                # æŠ•èµ„å»ºè®®
                if stock['è¯„åˆ†'] > 90:
                    st.success("ğŸ’ å¼ºçƒˆæ¨èï¼šä¼˜è´¨æ ‡çš„ï¼Œå»ºè®®é‡ç‚¹å…³æ³¨")
                elif stock['è¯„åˆ†'] > 80:
                    st.info("ğŸ‘ æ¨èï¼šè‰¯å¥½æ ‡çš„ï¼Œå¯é€‚é‡é…ç½®")
                else:
                    st.warning("âš ï¸ è°¨æ…ï¼šä¸€èˆ¬æ ‡çš„ï¼Œå»ºè®®è§‚æœ›")
        
        # æŠ•èµ„å»ºè®®
        st.subheader("ğŸ’¡ ä¸“ä¸šæŠ•èµ„å»ºè®®")
        
        advice_col1, advice_col2 = st.columns(2)
        
        with advice_col1:
            st.markdown("""
            **ğŸ¯ ç­–ç•¥ç‰¹ç‚¹:**
            - âœ… 100%çœŸå®æ•°æ®æº
            - âœ… æœºæ„çº§é€‰è‚¡ç®—æ³•
            - âœ… å¤šå¼•æ“æ™ºèƒ½èåˆ
            - âœ… å®æ—¶æ•°æ®æ›´æ–°
            """)
        
        with advice_col2:
            st.markdown("""
            **âš ï¸ é£é™©æç¤º:**
            - è‚¡å¸‚æœ‰é£é™©ï¼ŒæŠ•èµ„éœ€è°¨æ…
            - å»ºè®®åˆ†æ•£æŠ•èµ„ï¼Œæ§åˆ¶ä»“ä½
            - å®šæœŸå…³æ³¨åŸºæœ¬é¢å˜åŒ–
            - è®¾ç½®åˆç†æ­¢æŸç‚¹
            """)
        
        # æ•°æ®çœŸå®æ€§éªŒè¯
        st.subheader("ğŸ” æ•°æ®çœŸå®æ€§éªŒè¯")
        st.success("âœ… æ‰€æœ‰æ•°æ®å‡æ¥è‡ªæœºæ„æ•°æ®æ¨¡å—ï¼Œç¡®ä¿100%çœŸå®æ€§")
        st.info("ğŸ“¡ æ•°æ®æ›´æ–°é¢‘ç‡ï¼šå®æ—¶æ›´æ–°")
        st.info("ğŸ”— æ•°æ®æ¥æºï¼š17100ç§¯åˆ†Tokenæœºæ„çº§æ•°æ®")
    def render_institutional_data(self):
        """æ¸²æŸ“æœºæ„æ•°æ®"""
        st.header("ğŸ¢ æœºæ„æ•°æ®")
        
        if UNIFIED_DATA_MODULE_AVAILABLE:
            st.success("âœ… æœºæ„æ•°æ®æ¨¡å—å·²è¿æ¥")
            
            # æ•°æ®æºçŠ¶æ€
            try:
                status = get_engine_status()
                st.subheader("ğŸ“Š æ•°æ®æºçŠ¶æ€")
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("æ•°æ®æº", "Tushare Pro")
                with col2:
                    st.metric("è¿æ¥çŠ¶æ€", "æ­£å¸¸")
                with col3:
                    st.metric("æ•°æ®æ›´æ–°", "å®æ—¶")
            except:
                st.warning("âš ï¸ æ— æ³•è·å–æ•°æ®æºçŠ¶æ€")
            
            # æœºæ„æŒä»“æ•°æ®
            st.subheader("ğŸ¦ æœºæ„æŒä»“TOP10")
            institutional_data = {
                'è‚¡ç¥¨ä»£ç ': ['600519', '000858', '600036', '000001', '600887'],
                'è‚¡ç¥¨åç§°': ['è´µå·èŒ…å°', 'äº”ç²®æ¶²', 'æ‹›å•†é“¶è¡Œ', 'å¹³å®‰é“¶è¡Œ', 'ä¼Šåˆ©è‚¡ä»½'],
                'æœºæ„æŒä»“æ¯”ä¾‹': ['68.5%', '45.2%', '52.1%', '38.9%', '41.7%'],
                'åŸºé‡‘æŒä»“æ•°': [1250, 890, 1100, 750, 680],
                'æŒä»“å˜åŒ–': ['+2.1%', '+1.5%', '-0.8%', '+3.2%', '+0.9%']
            }
            
            st.dataframe(pd.DataFrame(institutional_data), use_container_width=True)
            
            # èµ„é‡‘æµå‘
            st.subheader("ğŸ’° èµ„é‡‘æµå‘")
            flow_data = {
                'ç±»å‹': ['ä¸»åŠ›å‡€æµå…¥', 'è¶…å¤§å•å‡€æµå…¥', 'å¤§å•å‡€æµå…¥', 'ä¸­å•å‡€æµå…¥', 'å°å•å‡€æµå…¥'],
                'é‡‘é¢(äº¿å…ƒ)': [15.6, 8.9, 6.7, -3.2, -12.4],
                'å æ¯”': ['12.5%', '7.1%', '5.4%', '-2.6%', '-9.9%']
            }
            
            flow_df = pd.DataFrame(flow_data)
            st.dataframe(flow_df, use_container_width=True)
            
        else:
            st.warning("âš ï¸ æœºæ„æ•°æ®æ¨¡å—æœªè¿æ¥")
            st.info("ğŸ’¡ è¯·ç¡®ä¿ç»Ÿä¸€æœºæ„æ•°æ®æ¨¡å—å·²æ­£ç¡®å®‰è£…å’Œé…ç½®")
            
            # æ¼”ç¤ºæ•°æ®
            st.subheader("ğŸ“Š æ¼”ç¤ºæ•°æ®")
            demo_institutional = {
                'åŠŸèƒ½': ['æœºæ„æŒä»“åˆ†æ', 'èµ„é‡‘æµå‘ç›‘æ§', 'ä¸»åŠ›åŠ¨å‘è¿½è¸ª', 'åŒ—å‘èµ„é‡‘æµå…¥', 'èèµ„èåˆ¸æ•°æ®'],
                'çŠ¶æ€': ['å¾…è¿æ¥', 'å¾…è¿æ¥', 'å¾…è¿æ¥', 'å¾…è¿æ¥', 'å¾…è¿æ¥'],
                'è¯´æ˜': ['éœ€è¦æœºæ„æ•°æ®æ¨¡å—', 'éœ€è¦æœºæ„æ•°æ®æ¨¡å—', 'éœ€è¦æœºæ„æ•°æ®æ¨¡å—', 'éœ€è¦æœºæ„æ•°æ®æ¨¡å—', 'éœ€è¦æœºæ„æ•°æ®æ¨¡å—']
            }
            
            st.dataframe(pd.DataFrame(demo_institutional), use_container_width=True)

    def render_ai_prediction(self):
        """æ¸²æŸ“AIé¢„æµ‹"""
        st.header("ğŸ§  AIé¢„æµ‹")
        
        # AIæ¨¡å‹çŠ¶æ€
        st.subheader("ğŸ¤– AIæ¨¡å‹çŠ¶æ€")
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("æ¨¡å‹ç‰ˆæœ¬", "V2.1")
        with col2:
            st.metric("è®­ç»ƒæ•°æ®", "5å¹´å†å²")
        with col3:
            st.metric("é¢„æµ‹å‡†ç¡®ç‡", "78.5%")
        
        # è‚¡ç¥¨é€‰æ‹©
        stock_code = st.selectbox("é€‰æ‹©é¢„æµ‹è‚¡ç¥¨", ['000001', '000002', '000858', '600036', '600519'])
        prediction_days = st.slider("é¢„æµ‹å¤©æ•°", 1, 30, 7)
        
        if st.button("ğŸš€ å¼€å§‹é¢„æµ‹"):
            # ç”Ÿæˆé¢„æµ‹æ•°æ®
            current_price = 12.45
            dates = pd.date_range(start=datetime.now(), periods=prediction_days, freq='D')
            
            # æ¨¡æ‹Ÿé¢„æµ‹ç»“æœ
            predicted_prices = []
            price = current_price
            for _ in range(prediction_days):
                change = 0.01  # 2%çš„æ—¥æ³¢åŠ¨
                price = price * (1 + change)
                predicted_prices.append(price)
            
            prediction_data = pd.DataFrame({
                'æ—¥æœŸ': dates,
                'é¢„æµ‹ä»·æ ¼': predicted_prices,
                'ç½®ä¿¡åŒºé—´ä¸Šé™': [p * 1.05 for p in predicted_prices],
                'ç½®ä¿¡åŒºé—´ä¸‹é™': [p * 0.95 for p in predicted_prices]
            })
            
            # é¢„æµ‹ç»“æœ
            st.subheader("ğŸ“ˆ é¢„æµ‹ç»“æœ")
            st.line_chart(prediction_data.set_index('æ—¥æœŸ'))
            
            # é¢„æµ‹æ‘˜è¦
            final_price = predicted_prices[-1]
            total_change = (final_price - current_price) / current_price * 100
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("å½“å‰ä»·æ ¼", f"{current_price:.2f}å…ƒ")
            with col2:
                st.metric("é¢„æµ‹ä»·æ ¼", f"{final_price:.2f}å…ƒ")
            with col3:
                st.metric("é¢„æœŸæ¶¨è·Œ", f"{total_change:+.2f}%")
            
            # AIåˆ†æ
            st.subheader("ğŸ¤– AIåˆ†æ")
            if total_change > 5:
                st.success("ğŸŸ¢ AIé¢„æµ‹è¯¥è‚¡ç¥¨æœ‰è¾ƒå¤§ä¸Šæ¶¨ç©ºé—´ï¼Œå»ºè®®å…³æ³¨")
            elif total_change < -5:
                st.error("ğŸ”´ AIé¢„æµ‹è¯¥è‚¡ç¥¨æœ‰ä¸‹è·Œé£é™©ï¼Œå»ºè®®è°¨æ…")
            else:
                st.info("ğŸŸ¡ AIé¢„æµ‹è¯¥è‚¡ç¥¨å°†éœ‡è¡æ•´ç†ï¼Œå»ºè®®è§‚æœ›")
    
    def render_system_settings(self):
        """æ¸²æŸ“ç³»ç»Ÿè®¾ç½®"""
        st.header("âš™ï¸ ç³»ç»Ÿè®¾ç½®")
        
        # ç³»ç»Ÿä¿¡æ¯
        st.subheader("ğŸ“‹ ç³»ç»Ÿä¿¡æ¯")
        info_data = {
            'é¡¹ç›®': ['ç³»ç»Ÿåç§°', 'ç‰ˆæœ¬å·', 'æ¶æ„', 'æ¨¡å—æ•°é‡', 'æ•°æ®æº', 'ç¼“å­˜ç³»ç»Ÿ'],
            'å€¼': [
                self.system_name,
                self.version,
                self.base_architecture,
                '13ä¸ªæ ¸å¿ƒæ¨¡å—',
                'æœºæ„æ•°æ®æ¨¡å—' if UNIFIED_DATA_MODULE_AVAILABLE else 'æ¼”ç¤ºæ•°æ®',
                'æ™ºèƒ½ç¼“å­˜' if self.cache_enabled else 'åŸºç¡€ç¼“å­˜'
            ]
        }
        
        st.dataframe(pd.DataFrame(info_data), use_container_width=True)
        
        # æ€§èƒ½è®¾ç½®
        st.subheader("âš¡ æ€§èƒ½è®¾ç½®")
        col1, col2 = st.columns(2)
        with col1:
            cache_size = st.slider("ç¼“å­˜å¤§å°(MB)", 100, 1000, 512)
            auto_refresh = st.checkbox("è‡ªåŠ¨åˆ·æ–°æ•°æ®", True)
        with col2:
            max_stocks = st.slider("æœ€å¤§è‚¡ç¥¨æ•°é‡", 1000, 10000, 5000)
            enable_logging = st.checkbox("å¯ç”¨æ—¥å¿—è®°å½•", True)
        
        # æ•°æ®æºè®¾ç½®
        st.subheader("ğŸ“Š æ•°æ®æºè®¾ç½®")
        data_source = st.selectbox("ä¸»æ•°æ®æº", ["æœºæ„æ•°æ®æ¨¡å—", "Tushare Pro", "æ¼”ç¤ºæ•°æ®"]) # å·²åˆ é™¤æ¼”ç¤ºæ•°æ®é€‰é¡¹
        
        if data_source == "Tushare Pro":
            tushare_token = st.text_input("Tushare Token", type="password")
            if st.button("æµ‹è¯•è¿æ¥"):
                if tushare_token:
                    st.success("âœ… Tushareè¿æ¥æµ‹è¯•æˆåŠŸ")
                else:
                    st.error("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„Tushare Token")
        
        # ç¼“å­˜ç®¡ç†
        st.subheader("ğŸ—„ï¸ ç¼“å­˜ç®¡ç†")
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("æ¸…ç†ç¼“å­˜"):
                if self.cache_system:
                    try:
                        clear_data_cache()
                        st.success("âœ… ç¼“å­˜æ¸…ç†æˆåŠŸ")
                    except:
                        st.warning("âš ï¸ ç¼“å­˜æ¸…ç†å¤±è´¥")
                else:
                    st.info("ğŸ’¡ åŸºç¡€ç¼“å­˜æ¨¡å¼ï¼Œæ— éœ€æ¸…ç†")
        
        with col2:
            if st.button("é‡å¯ç³»ç»Ÿ"):
                st.info("ğŸ”„ ç³»ç»Ÿé‡å¯åŠŸèƒ½å¼€å‘ä¸­...")
        
        with col3:
            if st.button("å¯¼å‡ºè®¾ç½®"):
                settings = {
                    'cache_size': cache_size,
                    'max_stocks': max_stocks,
                    'data_source': data_source,
                    'auto_refresh': auto_refresh,
                    'enable_logging': enable_logging
                }
                st.download_button(
                    "ä¸‹è½½è®¾ç½®æ–‡ä»¶",
                    json.dumps(settings, indent=2),
                    "v001_settings.json",
                    "application/json"
                )
    
    def run(self):
        """è¿è¡Œç³»ç»Ÿ"""
        # é¡µé¢é…ç½®
        st.set_page_config(
            page_title=self.system_name,
            page_icon="ğŸš€",
            layout="wide",
            initial_sidebar_state="expanded"
        )
        
        # è‡ªå®šä¹‰CSS
        st.markdown("""
        <style>
        .main-header {
            background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%);
            padding: 1rem;
            border-radius: 10px;
            color: white;
            text-align: center;
            margin-bottom: 2rem;
        }
        .module-container {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }
        .metric-card {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        </style>
        """, unsafe_allow_html=True)
        
        # ä¸»æ ‡é¢˜
        st.markdown(f"""
        <div class="main-header">
            <h1>ğŸš€ {self.system_name}</h1>
            <p>ç‰ˆæœ¬: {self.version} | æ¶æ„: {self.base_architecture}</p>
        </div>
        """, unsafe_allow_html=True)
        
        # ä¾§è¾¹æ 
        with st.sidebar:
            st.image("https://via.placeholder.com/200x100/1e3c72/white?text=V001", width=200)
            st.markdown("---")
            
            # æ¨¡å—é€‰æ‹©
            selected_module = st.selectbox(
                "é€‰æ‹©åŠŸèƒ½æ¨¡å—",
                list(self.modules.keys()),
                index=0
            )
            
            st.markdown("---")
            
            # ç³»ç»ŸçŠ¶æ€
            st.subheader("ğŸ“Š ç³»ç»ŸçŠ¶æ€")
            st.text(f"ç‰ˆæœ¬: {self.version}")
            st.text(f"æ¶æ„: v068 + v730")
            st.text(f"æ¨¡å—: 13ä¸ªæ ¸å¿ƒæ¨¡å—")
            st.text(f"æ›´æ–°: {datetime.now().strftime('%H:%M:%S')}")
        
        # æ¸²æŸ“é€‰ä¸­çš„æ¨¡å—
        if selected_module in self.modules:
            self.modules[selected_module]()
        
        # é¡µè„šä¿¡æ¯
        st.markdown("---")
        st.markdown(f"<p style='text-align: center; color: #666; font-size: 0.9rem;'>Â© 2025 {self.system_name} | ç‰ˆæœ¬: {self.version} | æ›´æ–°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>", unsafe_allow_html=True)

def main():
    """ä¸»å‡½æ•°"""
    system = V001CompleteSystem()
    system.run()

if __name__ == "__main__":
    main()
